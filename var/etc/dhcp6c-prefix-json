#!/usr/local/bin/python3
#
# *! IMPORTANT !*
#
#  This requires that Opensense pass the "-d" flag to dhcp6c
#  
#  To do this, go to "Interfaces" -> "Settings" and in the "IPv6 DHCP" options, 
#    change the log level to "Info"
#
# Debugging flag
DEBUG = True

# Parse ISC style configuration files (i.e. the dhcp6c.conf file)
#   https://pypi.org/project/iscpy/
#   PIP missing - install PIP on opnsense
#     https://pip.pypa.io/en/stable/installation/
#   https://stackoverflow.com/questions/19212176/parsing-isc-files-with-python-dhcpd-conf-iscpy-module
#   PyPI Version broken-instal here instead (install git first) 
#     https://github.com/egberts/iscpy/issues/1

import json
import re
import os
from datetime import datetime

saveFile = "/var/db/dhcp6c-pds.json"
dhcp6cConfFile = "/var/etc/dhcp6c.conf"
prefixFileTemplate = "/tmp/{}_prefixv6"

# Load existing data if it exists
existing_pd_data = {}
if os.path.exists(saveFile):
    try:
        with open(saveFile, 'r') as f:
            loaded_data = json.load(f)
        # Handle both old format (direct PD data) and new format (with summary)
        if "prefix_delegations" in loaded_data:
            existing_pd_data = loaded_data["prefix_delegations"]
        else:
            # Assume old format - direct PD data
            existing_pd_data = loaded_data
        if DEBUG:
            print(f"Loaded existing data with {len(existing_pd_data)} PD entries")
    except (json.JSONDecodeError, IOError) as e:
        if DEBUG:
            print(f"Could not load existing JSON file: {e}")
        existing_pd_data = {}

# Custom parse: extract all send ia-pd lines for each interface, merging across blocks
iface_pdids = {}
current_iface = None
pd_regex = re.compile(r'^send ia-pd\s+(\d+);')
iface_block_regex = re.compile(r'^interface\s+(\S+)\s*\{')
with open(dhcp6cConfFile, 'r') as f:
    for line in f:
        line_stripped = line.strip()
        iface_match = iface_block_regex.match(line_stripped)
        if iface_match:
            current_iface = iface_match.group(1)
            if current_iface not in iface_pdids:
                iface_pdids[current_iface] = []
        elif current_iface:
            match = pd_regex.match(line_stripped)
            if match:
                pdid = match.group(1)
                if pdid not in iface_pdids[current_iface]:
                    iface_pdids[current_iface].append(pdid)
        if line_stripped.startswith('};'):
            current_iface = None
if DEBUG:
    for iface, pdids in iface_pdids.items():
        print(f"custom parse: {iface} PD IDs: {pdids}")

# Start with existing data to preserve historical prefixes
pdDelegations = existing_pd_data.copy()
current_timestamp = datetime.now().isoformat()

for iface, pdids in iface_pdids.items():
    prefix_file = prefixFileTemplate.format(iface)
    if DEBUG:
        print(f"Checking interface: {iface}")
        print(f"  PD IDs: {pdids}")
        print(f"  Prefix file: {prefix_file}")
        print(f"  Exists: {os.path.exists(prefix_file)}")
    
    if not os.path.exists(prefix_file):
        if DEBUG:
            print(f"  Prefix file for {iface} does not exist, preserving existing data if any.")
        # Mark existing PD entries for this interface as potentially stale
        for pdid in pdids:
            if pdid in pdDelegations:
                if "last_seen" not in pdDelegations[pdid]:
                    pdDelegations[pdid]["last_seen"] = current_timestamp
                pdDelegations[pdid]["status"] = "prefix_file_missing"
                if DEBUG:
                    print(f"    Preserved existing PD {pdid}: {pdDelegations[pdid]['prefix']}")
        continue
    
    with open(prefix_file, 'r') as pf:
        prefixes = [line.strip() for line in pf if line.strip()]
    if DEBUG:
        print(f"  Prefixes found: {prefixes}")
    
    for pdid, prefix in zip(pdids, prefixes):
        if DEBUG:
            print(f"    Processing prefix {prefix} for PD {pdid}")
        
        # Update or create PD entry
        if pdid in pdDelegations:
            # Check if prefix has changed
            if pdDelegations[pdid]["prefix"] != prefix:
                if DEBUG:
                    print(f"    Prefix changed for PD {pdid}: {pdDelegations[pdid]['prefix']} -> {prefix}")
                # Store previous prefix in history
                if "prefix_history" not in pdDelegations[pdid]:
                    pdDelegations[pdid]["prefix_history"] = []
                pdDelegations[pdid]["prefix_history"].append({
                    "prefix": pdDelegations[pdid]["prefix"],
                    "timestamp": pdDelegations[pdid].get("last_updated", "unknown")
                })
                pdDelegations[pdid]["prefix"] = prefix
            pdDelegations[pdid]["status"] = "active"
            pdDelegations[pdid]["last_updated"] = current_timestamp
            pdDelegations[pdid]["interface"] = iface
        else:
            if DEBUG:
                print(f"    Creating new PD entry for {pdid}")
            pdDelegations[pdid] = {
                "prefix": prefix,
                "interface": iface,
                "allocations": False,
                "interfaces": {},
                "status": "active",
                "created": current_timestamp,
                "last_updated": current_timestamp
            }

# Add summary information to the output
summary = {
    "total_pds": len(pdDelegations),
    "active_pds": len([pd for pd in pdDelegations.values() if pd.get("status") == "active"]),
    "missing_prefix_files": len([pd for pd in pdDelegations.values() if pd.get("status") == "prefix_file_missing"]),
    "last_run": current_timestamp
}

output_data = {
    "summary": summary,
    "prefix_delegations": pdDelegations
}

# pdDelegations is already built above from prefix files and config order
# If you need to add interface allocation info, implement it here using your custom parser if needed.

if DEBUG:
    print(f"Writing {len(pdDelegations)} PD entries to {saveFile}")
    print(f"Summary: {summary}")

with open(saveFile, 'w+') as fileHandle:
  print(json.dumps(output_data, indent=4), file=fileHandle)
